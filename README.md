Дан кусок кода
```java
public class JvmComprehension {
    public static void main(String[] args) {
        int i = 1;                      // 1
        Object o = new Object();        // 2
        Integer ii = 2;                 // 3
        printAll(o, i, ii);             // 4
        System.out.println("finished"); // 7
    }

    private static void printAll(Object o, int i, Integer ii) {
        Integer uselessVar = 700;                   // 5
        System.out.println(o.toString() + i + ii);  // 6
    }
}
```

Процесс исполнения кода виртуальной машиной состоит из следующих этапов:
- Загрузка пакетов, необходимых для исполнения кода. Classloader'ы загружают пакет, либо делегируют это следующему загрузчику.
- Линковка классов и интерфейсов
- Инициализация статических полей, исполнение статических инициализаторов
- В указанном для исполнения классе находится метод **main**, для переменных метода на стеке выделяется новый фрейм
- Строка 1: для переменной **i** на стеке выделяется область памяти и инициализируется константой
- Строка 2: В куче выделяется область под объект типа **Object**, вызывается конструктор, на стеке выделяется место под ссылочную переменную **o** и инициализируется значением
- Строка 3: аналогично строке 1
- Строка 4: Выделяется на стеке новый фрейм под фунцию **printAll**, куда заносятся значения аргументов, поток исполнения переходит в функцию
- Строка 5: В зависимости от реализации jvm, возможно выделение памяти под переменную как в строке 1
- Строка 6: Создается новый анонимный объект типа **String**, инициализируется конкатенацией аргументов функции **printAll** и передается как аргумент функции **println**
- Фрейм стека освобождается, GC уведомляется что ссылочная переменная **o** прекратила существование, поток исполнения возвращается в метод main
- Строка 7: Вызывается функция **println**, в качестве аргумента передается ссылка на константную строку